# 準備 ---------------------------------------------------------------
# 以下のライブラリを読み込んでから以降の設問へ進んでください。

library(tidyverse)
library(dplyr)
library(ggplot2)

# [Tips] コンフリクト防止に以下のパッケージを設定しておくことをオススメします。

library(conflicted) # コンフリクト時エラーメッセージ
conflict_scout() # コンフリクト状況一覧
conflict_prefer(name = "select", winner = "dplyr") # 優先パッケージを指定

# 基礎 ---------------------------------------------------------------

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【1】csvファイルの読み込み
# 問題：inputフォルダ内のdata1.csvを相対パスで読み込み、変数dfとして保存してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df = read.csv('input/data1.csv'
              ,fileEncoding = "cp932"
              ,na.strings=c("", NULL,"NA")
              ,stringsAsFactors=F)

# [Tips]read.csvの主な引数
# fileEncoding：文字化けを防ぐためfileEncodinをする
# na.strings=c("", NULL,"NA") #指定した文字を欠損値として読み込む
# stringsAsFactors=F #文字列はfactor型に自動変換されるが、それを防ぐ

# [Tips]ファイル選択ダイアログから選択する場合はread.csv(file.choose())

# [Tips] 現在のworking directoryを確認するには getwd()
# [Tips] 現在のworking directoryを変更するには Sessionタブ> Set Working Directory > Choose Directory

# [Tips] git上で公開されているcsvの読み込み
# git上でcsvのディレクトリを開く > Rawをクリック > 遷移先のURLをread.csv('https://....csv') の形で読み込み

# [Tips] csvの出力
# write.csv(summary_data, "summary_iris.csv", fileEncoding = "CP932")

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【2】xlsxファイルの読み込み 
# 問題：library(readxl)を使ってinputフォルダ内のdata2.xlsxの
#　    「table」という名前のシートを相対パスで読み込み、変数df2として保存してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
install.packages("readxl") #初回のみ
library(readxl)
df2 = read_xlsx('input/data2.xlsx',
                sheet = "table",
                col_names = TRUE)

# [Tips]read_xlsxの主な引数
# col_names=TRUE  最初の行をdata.frameのカラム名として設定する
# range = "A1:D5" 指定した範囲のデータを読み込む場合に設定する

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【3】dfのコピー
# 問題：df_copyにdfをコピーしてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df_copy = df

# [Tips]pythonの場合、dfが変更されるとdf_copyの値も連動して更新されるが、Rの場合は更新されない。

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【4】dfの確認
# 問題：dfに読み込んだデータの最初の10行,最後の10行を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
head(df ,n = 10)
tail(df ,n = 10) 

# [Tips] nで表示するデータ数を指定しなければ表示するデータ数は6
# [Tips] nが大きい場合、表示されないことがある。その場合 print(df,n=..)の形で表示可
# [Tips] str(df) の形で各カラムのデータ型 + 値 を同時に確認可

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【5】基本データ型/データ構造型の確認
# 問題① df$Ageの基本データ型を確認してください。
# 　　② dfのデータ構造型を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mode(df$Age)
class(df)

# [Tips] データ型の詳細

##### 1.basic type(オブジェクトの型)
# 確認方法 mode()関数,typeof()関数
# 例 vector, list, function 等
# 注意点 vectorのときはvectorとは表示されず、vectorに含まれる要素の型が表示される

#### 2.vector型に含まれる要素の型
# 例 logical(0/1の二値), integer(整数), double(小数を含む実数), numeric(数値全般), complex, character, raw
# 注意点 typeof()ではintegerとdoubleは区別されるがmodeではnumericとまとめて表示される

#### 3.オブジェクトが持つ属性(ラベル情報)
# 確認方法 class()関数
# 例 factor, data.frame, tbl_df, matrix, array 等
# 注意点 matrix, arrayに関してはclass属性を持たないが,matrix, arrayとして表示される
# class属性を持たない場合、要素のデータ型が表示される

#### 4.日付型 
# 時刻を扱う型で正式名は「POSIXt 型,POSIXct 型,POSIXlt 型」の3種
# as.Date(date_column, format = "%d/%m/%Y"))
# lubridate パッケージを使用すると簡単 ※【7】を参考
# lubridate::dmy(date_column)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【6】データ構造型の確認
# 問題：dfのデータ構造型がvector,list,data.frameなのか順に確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is.vector(df)
is.list(df)
is.data.frame(df)

# [Tips] data.frame型はリスト型の1種として実装されています。

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【7】データ型の変換
# 問題：df$Parchを数値型から文字型に変換し、データ型(mode)を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df$Parch = as.character(df$Parch)
mode(df$Parch)

# [Tips]型変換をする主な関数
# as.numeric	  実数に変換する
# as.integer	  整数に変換する
# as.character	文字列に変換する
# as.logical	  理論値に変換する
# as.matrix     マトリクス型に変換する
# as.factor	    順序なし因子に変換する
# as.ordered	  順序あり因子に変換する
# as_tibble     data.frameをtibbleに変換する

# [Tips] mutate()を使った型変換
# df %>% mutate(X = as.integer(X))

# [Tips] lubridateパッケージを使った日付型への変換
# make_date(year,month,day) 日付型のデータを生成する
# ymd('2022,12,8') ⇒ [1] "2022-12-08"　とPOSIXクラス(日付型)に型変換する
# 作成されたPOSIXクラスのデータはdate(),year(),month() などで数値を取得できる

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【8】dfサイズの確認
# 問題：dfのサイズ(行数と列数)、サイズ(行数)、サイズ(列数)を表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dim(df)
nrow(df)
length(df) 

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【9】カラム名の一覧表示
# 問題：dfのカラム名一覧を表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
colnames(df)

# [Tips] rownames(df) で行名(行インデックス)の確認 - 文字列型で抽出されるので必要に応じてas.numeric処理
# [Tips] rownames(df) = df$... で...をrawIndexとして設定
# [Tips] rownames(a)=NULL で事実上のreset_index(1から連番に戻す)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【10】ベクトルから不要な要素の削除
# 問題：dfのカラム名の一覧からSurvivedを除いたリストを作成してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
x_col = c(colnames(df))
c(x_col[-which(x_col %in% "Survived")])

# [Tips] %in% 
# 左辺の要素が右辺の要素とマッチしていたらTRUEを返す二項演算子
# 具体的には x_col = ["PassengerId","Survived","Pclass",… ,"Embarked"]に対して、
# [FALSE,TRUE,FALSE,…,FALSE]という同じ長さのベクトルが返ってくる
# filter()関数でも使える

# [Tips] which
# 指定された条件を満たす(=TRUE)要素のインデックス番号を返す関数
# 具体的には [FALSE,TRUE,FALSE,…,FALSE]に対して、[2]というインデックス番号が返ってくる

# [Tips] ベクトル[-n]
# ベクトルからn番目の要素を削除する

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【11】変数の一括削除
# 問題：現在のEnvironmentに含まれる変数を全て削除してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# rm(list = ls()) # 以降の設問でも変数は使用するためコメントアウトしています。

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【12】関数の詳細確認
# 問題：read_excel関数の構文、引数などを確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
help(read_excel) 

# [Tips]?read_excelでもよい

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【13】関数を定義する
# 問題：与えられた2変数a.bを足す関数addを作成し、a=5,b=10に適用してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
add = function(a,b){a+b}
add(5,10)

# [Tips] 繰り返し処理for
# for (i in 1:100) {s = s + i} が基本の形
# pythonに慣れていると in list型としたくなりますが、数値を設定する点に注意
# リストでも動くかは要検証

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【14】data.frameの生成
# 問題：name=c("Tanaka","Suzuki"),age=c(15,16)を持つデータフレームtmpを作成してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tmp = data.frame(name=c("Tanaka","Suzuki"),age=c(15,16))

# [Tips] 空のdfの生成と繰り返し処理for,rbindの組み合わせ
# df = data.frame() 
# counter = 0
# for (i in 1:5){ 処理
#   df = rbind(df,処理で生成されたdf)
#   counter = counter +1
#   print(counter)
#   }
# counter = counter +1
# print(counter)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【15】ショートカット
# 問題：以下のショートカットキーを確認してください。

# ①pipe演算子(`%>%`)を作成する
# ②コメントアウトする
# ③セクションを作成する
# ④ ctrl+zで戻ってから「進む」(redo)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ①ctrl+shift+M 
# ②Ctrl+Shift+C 
# ③Ctrl+Shift+R 
# ④Ctrl+Shift+Z

# [Tips]セクションは折りたためたり、コンソール画面上でジャンプしやすかったりと非常に強力！

# 抽出 ---------------------------------------------------------------

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【16】列の抽出
# 問題：dfのNameの列をtmpとして抽出してください。
#       tmpのデータ構造型がベクトルではなくdata.frameであることを確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tmp = df %>% select(Name)

is.vector(tmp)
is.data.frame(tmp) 

# [Tips] selectを使って1列を指定した場合、そのままdata.frame型で抽出

# [Tips] 1列だけの選択のとき、pull関数を使うことでvector型として抽出
# df %>% pull(Name)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【17】列の抽出(*selectは使わない)
# 問題：selectを使わずdfのName列をtmpとして抽出してください。 
#       tmpのデータ構造型がdata.farmeではなくベクトル型であることを確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tmp = df[,"Name"]

is.vector(tmp)
is.data.frame(tmp) 

# [Tips] [,…]を使って1列を指定した場合、自動的にベクトル型に変換される
# [Tips] df$Name でも同義

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【18】指定列以外の抽出
# 問題：dfのName列以外の列を抽出してください。 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  select(-Name)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【19】複数列の抽出
# 問題：dfのNameとAgeの列を抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  select(Name,Age)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【20】条件を満たすデータの抽出
# 問題：dfのage列の値が30以上のデータを抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  filter(Age >= 30)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【21】条件を満たさないデータの抽出
# 問題：dfのsex列がfemaleではないデータのみ抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  filter(Sex != "female")

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【22】複数条件をいずれも満たすデータの抽出
# 問題：dfのage列の値が40以上かつsex列がfemaleのデータのみ抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  filter(Sex == "female" & Age >= 40)

# [Tips] 同一カラム内の複数の値を条件付ける場合の %in%
# filter (Sex %in% c('male','female'))のようにc()でまとめても可

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【23】複数条件のいずれかを満たすデータの抽出
# 問題：dfのage列の値が40以上またはsex列がfemaleのいずれか一方は満たすデータを抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  filter(Sex == "female" | Age >= 40)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【24】複数条件のいずれも満たさないデータの抽出
# 問題：dfのage列の値が40以上ではない かつ sex列がfemaleではないデータを抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  filter(!(Sex == "female" | Age >= 40))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【25】特定のカラムに任意の文字列が含まれるデータの抽出
# 問題：dfのname列に[Mrs]が含まれるデータを抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  filter(str_detect(Name, "Mrs"))

# [Tips] 特定のカラムから特定の文字数だけ抽出して新しいカラムを生成する ⇒ 【55】へ

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【26】カラム名に任意の文字列が含まれるデータの抽出(ヘルパ関数)
# 問題：dfの[P]を含むカラム名のデータを抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  select(contains("P"))

# [Tips]主なヘルパ関数(複数のカラムを簡単に指定できる)
# starts_with('hoge')  任意の文字列から始まる
# contains('hoge')     任意の文字列を含む
# everything('hoge')   全ての列を選択
 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【27】特定の文字列が含まれるデータの抽出
# 問題：dfのname列に[Mrs]が含まれるデータを抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  filter(str_detect(Name, "Mrs"))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【28】上位n・下位nの抽出
# 問題：dfの中でFareの上位10件を抽出後、下位10件を抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% top_n(10, Fare)
df %>% top_n(-10, Fare)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【29】特定のデータ型の列の抽出
# 問題：dfの中で数値型の列のみ抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  select(where(is.numeric)) 

# 加工 ---------------------------------------------------------------

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【30】不要列の削除(selectを用いた削除)
# 問題：select関数を用いてdfからSibSpの列を削除してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  select(-SibSp) 

# 複数カラムを削除する場合
# select(-c(flag,id))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【31】不要列の削除(NULLを用いた削除)
# 問題：NULLを用いてdfからParchの列を削除してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df[, "Parch"] = NULL

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【32】dfの要素の上書き
# 問題：dfの4行目のAge列を40に上書きしてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df[4,"Age"]=40

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【33】カラムの追加
# 問題：dfに列名「test」で値がすべて1のカラムを追加してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  mutate(test = 1)

# [Tips] 架空のランダムデータの生成
# rnorm(n=100, mean=1, sd=1) #正規分布
# runif(n=100, min=0, max=10) #一様分布,範囲を指定して乱数生成
# rpois(n=100, lambda=5) #ポアソン分布
# rbinom(n=100, size = 50, prob = 0.5) # 二項分布,成功確率50%を50回試行した結果の値を100個生成する

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【34】任意列の値を条件とした新カラムの追加
# 問題：dfのAge列にて>60の場合に1が立つ、新しいカラム「over60」を追加してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  mutate(over60 = if_else(Age > 60,1,0))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【35】任意の列の値を置換する
# 問題：dfのsex列にてmale→0、それ以外→1に置換してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>%
  mutate(Sex = if_else(Sex == "male",0,1))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【36】場合分けした値の置換
# 問題：dfのEmbarked列にてc→1、Q→2、S→3に置換し,データ型をnumeric型に変更してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>%
  mutate(Embarked =
           case_when(
             Embarked == "C" ~ "1",
             Embarked == "Q" ~ "2",
             Embarked == "S" ~ "3",
             TRUE ~ as.character(Embarked)
           )) %>%
  mutate(Embarked = as.numeric(Embarked))

# [Tips]case_whenでは元と同じ型で一度出力する必要があり、その後as.numericで数値型に直している

# [Tips]複数列に同じ関数処理をしたい場合

# 対応方法1.apply()関数
# apply(df,方向フラグ,function) 行方向に適用する場合は1、列方向に適用する場合は2を指定
#
# df[to_enc_col] =
#  apply(df[to_enc_col],2,function(x){
#    x = str_to_upper(x) # 大文字にする関数
#    })

# 対応方法2.across()関数
# df %>% mutate(across(
#                  .cols = c("species", "sex"), # 関数を適用する列を指定
#                  .fns = str_to_upper) # 適用する関数名

# [Tips] 1行だけの簡易置換はifelseが便利
# 例 . df %>% mutate(Weekly_Sales = ifelse(Weekly_Sales<0, 0, Weekly_Sales))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【37】丸め表示
# 問題：dfのfare列すべてを小数点以下で丸めてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
round(df$Fare,1)

# [Tips]round関数は偶数への最近接丸めされる
# 端数が <0.5のとき切り捨て >0.5のとき切り上げ =0.5のとき切り捨てと切り上げのうち偶数となる方へ丸める

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【38】カラム名の変更
# 問題：dfに含まれる次の列名を変更してください。
#       Pclass⇒class, Parch⇒parch
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>%
  rename(class = Pclass,
         parch = Parch)

# [Tips] selectでselect(新列名 = 旧列名)とする形でも可
# [Tips] colnames(df) = names(list_data) の形も可. namesはベクトル型のインデックスを取得する.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【39】並び替え
# 問題：dfのAgeを基準に降順に並び替えてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% arrange(desc(Age)) 

# [Tips] arrange(df,列名)で昇順
# [Tips] 複数条件かつ降順のときはdescが2つ必要なので注意
# data %>% arrange(desc(id),desc(ds))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【40】転置
# 問題：dfの行と列を入れ替えた形に並び替えてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
t(df)

# 重複処理 ---------------------------------------------------------------

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【41】ユニークな要素の確認
# 問題：dfのSexの列のユニークな要素を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
unique(df$Sex)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【42】ユニークな要素数の確認
# 問題：dfのSex列のユニークな要素数を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
n_distinct(df$Sex)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【43】カラム別のユニークな要素数の確認
# 問題：ibrary(skimr)を使ってdfの各列のユニークな要素数を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
library(skimr)
skim(df) # n_unique列を確認する

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【44】ユニークな要素とその出現回数の確認
# 問題：dfのembarked列の要素と出現回数を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% summarise(hoge=n(),.by = Embarked)

# [Tips] 集計関数n() はデータの行数をカウントします。

# [Tips] group_by を使った方法(現在は非推奨)
# group_byでグループ化された状態でsummarise(xxx = 集計関数())でグループ別に集計できます。
# 例. df %>% group_by(Embarked) %>% summarise(hoge=n(),by = Embarked)
# 現在は summarise()の引数 .byで指定することが推奨されています。

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【45】重複の削除
# 問題：dfのcabin、Ticket列で重複を削除し、data.frame全体を抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% distinct(Cabin,Ticket.keep_all = T) 

# [Tips] 重複があった場合は初出の情報のみ残る。
# .keep_allがない場合、削除確認に使ったカラムのみ抽出される。

# 欠損値処理  ---------------------------------------------------------------
# {base}を使った基本的な処理ではなく、ここではモダンな処理方法をまとめた

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【46】NAの個数の確認 {base機能}
# 問題：dfのカラムごとの欠損値の個数を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
colSums(is.na(df)) 

# [Tips]colSumsは対象のdata.frame,カラムの合計値を算出する

# [Tipe]変数が多い場合見づらいので以下の形で降順にするとよい
# data.frame(missing_cnt = colSums(is.na(df))) %>% filter(missing_cnt > 0) %>% arrange(desc(missing_cnt))

# [Tips] 欠損値の可視化用ライブラリnaniar
# missing_col = row.names(data.frame(missing_cnt = colSums(is.na(df))) %>% filter(missing_cnt > 0))
# gg_miss_var(df %>% select(missing_col), show_pct = TRUE)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【47】NAの個数の確認 {library(skim)}
# 問題：library(skim)を使って、dfのカラムごとの欠損値の個数を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skim(df)

# [Tips]n_missingの列で欠損値の確認が可能です。

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【48】NAに置換する
# 問題：dfのSex列のfemaleをNA(欠損値)にする
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>%
  mutate(Sex = na_if(Sex ,"female"))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【49】欠損値の補完(文字列)
# 問題：dfのSex列の欠損値を"female"で補完してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>%
  replace_na(replace = list(Sex="female"))

# [Tips] 一括で欠損値を0に置換したい場合
# df %>% mutate_all(~replace(., is.na(.), 0)) を使う
# mutate_all() はmap()ファミリーの関数を内部的に使用しており、
# 各列に対してラムダ式「~ + 関数」を適用する.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【50】欠損値の補完(数値) - グループ平均値代入法
# 問題：dfのAge列の欠損値をSex別のAgeの平均値で補完してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>%
  mutate(new_age = if_else(is.na(Age),mean(Age,na.rm=T),Age),
         .by = Sex)

# [Tips] mutate()でグループごとに値を追加する方法
# mutateもgroupを引数に取ることが可能

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【51】欠損値の補完(直前の値を採用) - LOCF法
# 問題：dfをFareの降順にした上で、Age列の欠損値をその直前の方の値で補完してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% arrange(-Fare) %>% fill(Age)

#　[Tips] .direction = "up" を指定することでデータを上向きに補完する

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【52】欠損値を含むデータの削除 - リストワイズ法
# 問題：df$Age列で1つでも欠損値がある行を削除してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df = df %>% drop_na(Age)

# [Tips]全カラムで一気にチェック・削除する場合はdrop_na(everything())

# 文字列の操作 ---------------------------------------------------------------

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【53】大文字に変換
# 問題：library(stringr)を使ってdfのnameの列をすべて大文字に変換し、その後すべて小文字に変換してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
library(stringr)

toupper(df$Name)
tolower(df$Name)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【54】文字列の置換
# 問題：dfのsex列に含まれる「female」という単語を「Python」に置換してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
str_replace_all(df$Sex, pattern="female", replacement="Python")

# [Tips]

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【55】文字列の一部抽出
# 問題：dfのname列1行目の「Braund, Mr. Owen Harris」の「Harris」を消去してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
str_replace(df[1,"Name"],pattern="Harris", replacement="")

# [Tips] {base_R}文字列の一部抽出
# substring("aaavvv",first = 1,last = 3) 開始地点と終了地点を指定

# [Tips] {stringrパッケージ}文字列の一部抽出
# library(stringr)

# str_sub("aaavvv" , start = -3, end = -1) 開始地点と終了地点を指定,負の値も使用可能
# mutate(hoge = str_sub(train$huge,start = -3 ,end = -1)) hugeの後ろから3文字を抽出したhoge列を追加する

# str_locate：指定パターンにマッチする箇所の文字数を返す , start end の2値が戻り値 ※最初の箇所以外も見たい場合はstr_locate_all()

# str_subset：指定パターンを含む文字列を返す

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【56】文字列の結合
# 問題：dfにage(num型)とembarked(chr型)の列を「_」で結合した列を追加(列名はtest)してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>%
  mutate(test = paste(Age,Embarked,sep = "_"))

# [Tips] paste(Age,"_",Embarked)でもいいがスペースが入り見づらい
# [Tips] sep = "" と指定することで文字列を詰めた状態で抽出することが可能

# マージと連結 ---------------------------------------------------------------

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【57】左結合
# 問題：df2にdfを左結合（結合キーはPassengerId）し、df2に格納してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df2 = left_join(df2,df,by="PassengerId")

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【58】内部結合
# 問題：df2にdfを内部結合（結合キーはPassengerId）し、df2に格納してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df2 = inner_join(df2,df,by="PassengerId")

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【59】下に結合
# 問題：df2(714行22列)とdf2を行方向に連結したaを作成し、行列数を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
a = rbind(df2,df2)
dim(a)

# [Tips] df union(df2) と同義.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【60】右に結合
# 問題：df2(714行22列)とdf2を列方向に連結したbを作成し、行列数を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
b = cbind(df2,df2)
dim(b)

# [Tips]rbindのrはrawを維持した状態での結合、つまり下に付与される形
#　　　 cbindのcはcolumnを維持した状態での結合、つまり右に付与される形

# [Tips] 任意の配列をdfに追加する
# data.frame(df2 , name = df$name) という書き方で
# df2にname列を追加するという処理ができる

# ラベリングとスケーリング ---------------------------------------------------------------

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【61】ラベルエンコーディング
# 問題：dfのsex列をラベルエンコーディング(1,2,…)してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sex_enc = df %>% 
  distinct(Sex, .keep_all = F) %>%
  mutate(Sex_label = as.numeric(as.factor(Sex))) 

df = left_join(df,Sex_enc,by="Sex")
head(df)

# [Tips] as.factorで順序を持った因子型に変換した後、as.numericを使い数値のみ取得

# [Tips] 条件に応じた値の置換に関しては【36】を参照すること

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【62】One-hotエンコーディング
# 問題：dfのSex列をOne-hotエンコーディングしてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>%
  mutate(dummy = 1) %>%
  pivot_wider(names_from = "Sex",
              values_from = "dummy",
              values_fill = 0) #NAを指定の値に置換する

# [Tips] recipesパッケージ::step_dummy()を使った方法

# library(recipes)
# df_rec =　
# recipe(x = df , formula = target_col ~ .) %>% 
# step_dummy(all_nominal_predictors()) %>% 
# prep() %>% 
# bake(new_data = NULL)

# [Tips] step_*()関数内で使えるヘルパ関数

# start_with()   列名の接頭語で取捨選択（列名の頭にある共通の文字列などを認識させて選択）
# ends_with()    列名の接尾語で取捨選択（列名の後ろにある共通の文字列などを認識させて選択）
# contains()     指定した文字列が含まれる列を取捨選択
# matches()      正規表現で列を取捨選択
# everything()   すべての列を取捨選択
# all_of()       与えられた変数名とすべて合致する変数の組み合わせ
# any_of()       与えられた変数名と合致する変数.合致しないものは無視
# all_predictors モデル式の説明変数
# all_numeric_predictors 数値型のすべての説明変数
# all_nominal_predictors 文字列型,factor型のすべての説明変数
# has_role       role
# has_type       type

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【63】正規化
# 問題：dfのAge列を正規化(平均0,分散1)してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
scale(df$Age)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【64】min-MAXスケーリング(0-1)
# 問題：dfのAge列を最小値0最大値1となるようにmin-MAXスケーリングしてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
scale(df$Age,
      center = min(df$Age), 
      scale = (max(df$Age) - min(df$Age))) 

# [Tips]関数scaleの引数の説明
# center：数値ベクトルの場合は対応する値を引き、Trueの場合は全体平均値を引く
# scale：数値ベクトルの場合は対応する値で割り、Trueの場合は全体分散で割る

# 集計・統計 ---------------------------------------------------------------

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【65】要約統計量の確認
# 問題：dfの要約統計量を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
summary(df)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【66】要約統計量の確認 
# 問題：library(skimr)を使って、dfの要約統計量を確認してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
library(skimr) # パッケージ名には「*r」が付くので注意
skim(df) 

# [Tips] dfSummaryを使っても良い(htmlで別ウィンドウが立ち上がる)
# library(summarytools)
# dfSummary(dataset) %>% view()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【67】グループごとの集計(合計)
# 問題：dfのEmbarkedとSexの掛け合わせごとにFareの合計を集計し、df_として保存してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df_ = df %>%
  summarise(Fare_Sum = sum(Fare),.by = c(Embarked,Sex))

# [Tips] .byで複数条件を指定するときはc(hoge,hoge)の形
# [Tips] group_by()は現在は推奨されていない

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【68】平均値
# 問題：dfのsex別にage列の平均値を求めてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% summarise(Ave = mean(Age, na.rm=T),.by = Sex) 

# [Tips]na.rm=TはNAを集計対象から除く処理

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【69】中央値
# 問題：dfのsex別にdfのage列の中央値を求めてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% summarise(Med = median(Age, na.rm=T),.by = Sex)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【70】最大値、最小値
# 問題：dfのSex別にage列の最大値、最小値を1つのdata.frameで示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  summarise(MAX = max(Age, na.rm=T),
            MIN = min(Age, na.rm=T),
            .by = Sex)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【71】標準偏差、分散
# 問題：dfのSex別にage列の標準偏差、分散を1つのdata.frameで示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  summarise(sd = sd(Age, na.rm=T),
            var = var(Age, na.rm=T),
            .by = Sex)

# [Tips] 共分散の計算は cov(x,y) 

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【72】相関係数
# 問題：dfのnumeric型同士の相関を求めてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cor(df %>% select(where(is.numeric)))

# [Tips] with(df , cor(...,...)) という書き方も可
# with()は第1引数のdfの項目からオブジェクトを取得し、第2引数に与えられた処理を実行する

# [Tips] select(where(列指定))
# select_if()やselect_at()が以前は使われていたものの、現在はwhereを使う形が推奨

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【73】パーセンタイル
# 問題：dfのAge列の0、23、50、75、100パーセンタイルを取得してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
quantile(df$Age, c(0, 0.23, 0.5, 0.75, 1))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【74】要素別の頻度カウント
# 問題：dfのAge列における各要素の頻度を求めてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
table(df$Age)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【75】最頻値
# 問題：最頻値とそのときの頻度を表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
rev(sort(table(df$Age)))[1]

# [Tips]頻度のtableを作成し、rev(sort())で降順にすると[1]番目の値が最頻値

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【76】データの縦持ち(tidy)⇒横持ち
# 問題：dfのSex別にFareの平均をpivotを使って求めてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

wider = df %>%
  select(Sex,Fare) %>%
  pivot_wider(names_from = "Sex",
              values_from = "Fare",
              values_fn = mean)
wider

# [Tips]関数pivot_widerの引数の説明
# ・names_from：表頭に移動させたいカラム名、ここで指定されていないカラムはそのまま表側に残る
# ・values_from：実際に表示してほしい値
# ・values_fn：集計関数を使いたい場合に設定

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【77】tidy data形式への変換(横持ち⇒縦持ち)
# 問題：先ほど作成したwiderをpivotを使ってtidy data(縦持ち)にしてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

wider %>%
  pivot_longer(cols = c("male","female"),
               names_to = "sex_flag",
               values_to = )

# [Tips]関数pivot_longerの引数の説明
# ・cols：対象列の指定
# ・names_to：対象列のカラム名を1列にまとめたとき、その列の名称
# ・values_to：対象列のデータを1列にまとめたとき、その列の名称

# [Tips] ヘルパ関数を上手に使おう - 【26】【62】を参考

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【78】window関数- row_number
# 問題：Sex別にFareが多い順に1.2.3...と連番を振った列を追加し、TOP3のみ抽出してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  arrange((desc(Fare))) %>% 
  mutate(num = row_number(),.by = Sex) %>% 
  filter(num >=1 & num <=3)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【79】window関数- lag
# 問題：Fareを降順に並べたとき、直前の人のFareの差を求めよ
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df %>% 
  arrange((desc(Fare))) %>% 
  mutate(dif = lag(Fare,n=1) - Fare)

# [Tips]集約関数とWindow関数の違い
# ・集約関数は、複数の入力レコードに対し、1つのレコードを出力します。
# ・Window関数は、複数の入力レコードに対し、レコード毎に1つのレコードを出力します。

# 可視化 ---------------------------------------------------------------
#「geom_*()関数で引数にstatを取る方法」と「stat_*()関数で引数にgeomを取る方法」がありここでは前者に統一します。

# ggplot()+geom_*()が基本の形
# data = …, mappinnng = aes(x=…,y=…)をggplot関数またはgeom_*関数内のいずれかで指定します。

# [Tips]geom_*で使われる主な引数
# stat(集計方法) =  "bin" "identity(そのまま)" "count" "sum" "mean" "density" "summary"など
# position(並べ方) = "stack"(積み上げ) ,"fill"(100%積み上げ),"identity"(配置調整しない),"dodge"(横並び)

# stat = "summary",fun = 統計量 の形で集計しつつ可視化できる

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【80】ヒストグラム
# 問題：dfのAge列のヒストグラムを作成してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Age))+
  geom_histogram()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【81】密度推定曲線
# 問題：dfのAge列の密度推定曲線を作成してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Age))+
  geom_density(stat = "density")

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【82】複数のヒストグラム
# 問題：dfのAge列のヒストグラムをSex別に作成し、重ねて表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Age ,fill=Sex))+ 
  geom_histogram(position = "identity" ,alpha = 0.5)

# [Tips] geom_histogram は= "count"がデフォルト設定されており自動でcountされます。
# [Tips] aes()の引数におけるfill = ...は塗りつぶしの色分け条件を指定します。同様にcolor = ...は枠などの線の色分け条件を指定できます。

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【83】棒グラフ
# 問題：dfのEmbarkedごとにFareの合計を棒グラフで表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Embarked,y=Fare))+
  geom_bar(stat  = "summary" ,fun = "sum")

# [Tips] geom_*()の引数で「stat = "summary",fun = 統計量」を使うと可視化させつつ集計できる。

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【84】降順表示(棒グラフ)
# 問題：dfのEmbarkedごとにFareの合計を棒グラフで降順に表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df_ = df %>% summarise(Fare_Sum = sum(Fare),.by = Embarked) %>% arrange(desc(Fare_Sum))

ggplot(data = df_, mapping = aes(x = fct_reorder(Embarked,Fare_Sum, .desc = TRUE),
                                 y = Fare_Sum))+
  geom_bar(stat  = "identity")

# [Tips] 集計後のテーブルに対して、fct_reorderを使う。
# そのときfct_reorder(並べ替える変数,並べ替えの基準に利用する変数, .desc = TRUE)の形で
# 降順に並べ替えることができる。

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【85】棒グラフの並列表示
# 問題：dfのEmbarkedごとにFareの合計をSexで色分けし、棒グラフでSexが隣り合う形で表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Embarked,y=Fare,fill=Sex))+
  geom_bar(stat  = "summary" , position = "dodge" , fun = "sum") 

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【86】積み上げ棒グラフ(対 集計済データ)
# 問題：① dfのEmbarked,Sex別にFareの合計(変数名：Fare_Sum)を求めて、df_として格納してください。
# ②df_のEmbarkedごとにFareの合計をSexで色分けし、積み上げ棒グラフで表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df_ = df %>% summarise(Fare_Sum = sum(Fare),.by=c(Embarked,Sex))

ggplot(data = df_, mapping = aes(x=Embarked,y=Fare_Sum,fill=Sex))+
  geom_bar(stat  = "identity" ,position = "stack" ,alpha = 0.5) 

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【87】横棒グラフ
# 問題：dfのEmbarkedごとにFareの合計を横棒グラフで表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Embarked,y=Fare))+
  geom_bar(stat  = "summary" ,fun = "sum")+
  coord_flip()

# [Tips] coord_flip()はx,y軸を入れ替える

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【88】散布図の一括表示
# 問題：dfの全ての値を対象に散布図を表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
plot(df)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【89】散布図
# 問題：dfのageとFareの散布図を表示し、Sexで色分けしてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Age,y=Fare,color=Sex))+
  geom_point() 

# [Tips] ポイントなど点や線の色分け条件は、colorで指定する
# [Tips] 棒グラフなどの塗りの色分け条件は、fillで指定する

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【90】ヴァイオリンプロット
# 問題：dfのEmbarked別にFareのヴァイオリンプロット(四分位範囲有)を表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Embarked,y=Fare,fill=Embarked))+
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75))

# [Tips] 四分位範囲を表示しない場合、draw_quantilesは不要

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【91】棒グラフ+散布図
# 問題：dfのEmbarked別にFareの平均値を棒グラフで示し、その上に散布図を表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Embarked,y=Fare))+
  geom_bar(stat  = "summary" ,fun = "mean")+
  geom_jitter(mapping = aes(color = Embarked))

# [Tips] geom_jitterは描画位置を散らした散布図を直接出力してくれる。

# [Tips] Raincloud plotをggdistパッケージを使って作成する

# library(ggdist)
# ggplot(iris, aes(x = Sepal.Length, y = Species,color =Species)) +
#  # 確率密度分布
#  stat_halfeye(point_color = NA, # 点推定を削除
#               .width = 0, # 信頼区間の線分を削除
#               height = 0.6,# グラフの高さ調整
#               position = position_nudge(y = 0.3))+ # グラフ自体を移動させる
# # jitterを使った散布図
#  geom_jitter(width = 0, height = 0.1)+ # 分布の散らばり幅を限定しておく
# # 箱ひげ図
# geom_boxplot(position = position_nudge(y = 0.2),# グラフ自体を移動させる
#                 width = 0.1,
#         outlier.shape = NA) # 外れ値をプロットしない

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【92】散布図のラベリング
# 問題：dfのageとFareの散布図を表示し、library(ggrepel)を使って主要なNameを示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
library(ggrepel)
ggplot(data = df, mapping = aes(x=Age,y=Fare))+
  geom_point() +
  geom_text_repel(aes(label = Name), size = 3)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【93】装飾
# 問題：92で作成したグラフに以下の要素を付与してください。
# ①タイトル： Age-Fare scatter
# ② 出典：xxx
# ③ X軸：年齢
# ④ Y軸：料金
# ⑤ テーマ：theme_classic()　片方の枠のみ、罫線なし
# ⑥ 文字サイズ14とフォントserifへ変更
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Age,y=Fare,color=Sex))+
  geom_point() +
  geom_text_repel(aes(label = Name), size = 3) +
  labs(title = "Age-Fare scatter",
       caption = "出典：xxx",
       x = "年齢",
       y = "料金")+
  theme_classic(base_size = 14,base_family = "serif")

# [Tips]theme_*は複数存在するので好みのものを見つけておくとよい。base_familyはフォントのこと。
# [Tips]theme(legend.position = "none",
#        axis.title.x = element_blank(),
#        axis.title.y = element_blank() とすることで凡例、X軸ラベル、y軸ラベルを削除できる。

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【94】相関ヒートマップ
# 問題：library(corrplot)を使ってdfの数値型全体の相関ヒートマップ(少数第二位まで表示)を示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
library(corrplot)
corrplot(cor(df %>%
               select(where(is.numeric))) %>%
           round(3),
         method="color",
         addCoef.col=TRUE,
         sig.level=0.01)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【95】箱ひげ図
# 問題：dfのEmbarked別にFareの分布を箱ひげ図で示してください。
#       ただし、SとCだけ比較とし、それぞれ色は分けてください。(Q,NAは非表示)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df,
       mapping = aes(x=Embarked, y = Fare,fill=Embarked))+ 
  geom_boxplot()+
  scale_x_discrete(limits=c("S","C"))+
  scale_y_continuous(limits = c(0,100))

# [Tips] scale_x_discrete(limit=C( ,…))は離散型のx軸で表示する「要素と順序」を指定できる
# [Tips] scale_y_continuous(limits = c( ,…))は連続型のy軸で表示する「値の範囲」を指定できる
# [Tips] scale_y_continuous(breaks=seq(0,420,30))は1引数と2引数の間に軸の値を表示する。その際、3引数が軸の値の間隔

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【96】補助線の追加
# 問題：dfのageとFareの散布図を表示し、性別ごとに回帰直線を引き、さらに40歳のところに縦線を引いてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Age,y=Fare,color=Sex))+
  geom_point() +
  geom_smooth(mapping = aes(group = factor(Sex)),method = "lm",se = TRUE)+
  geom_vline(xintercept = 40)

# [Tips] geom_abline(intercept = …, slope = …,linetype = "dotdash")で任意の傾きの直線が引ける
# [Tips] グループごとの形で対応する場合、aes()の引数で group = ...を指定する

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【97】回帰直線の追加(特定の範囲の切り出し)
# 問題：dfのageが45-55歳のデータを抽出し、AgeとFareの散布図を表示し、性別ごとに回帰直線を引いてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Age,y=Fare,color=Sex))+
  geom_point() +
  xlim(45,55)+
  geom_smooth(mapping = aes(group = factor(Sex)),method = "lm",se = TRUE)+
  geom_vline(xintercept = 40)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【98】回帰直線の追加(特定の範囲の拡大表示)
# 問題：dfのageとFareの散布図を表示し、性別ごとに回帰直線を引き、45-55歳を拡大表示してください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Age,y=Fare,color=Sex))+
  geom_point() +
  coord_cartesian(xlim =c(45,55))+
  geom_smooth(mapping = aes(group = factor(Sex)),method = "lm",se = TRUE)+
  geom_vline(xintercept = 40)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【99】複数の回帰直線を追加
# 問題：dfのageとFareの散布図を性別で色分けして表示後、
#       45-55歳のデータのみを元に性別ごとに回帰直線を引いてください。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot()+
  geom_point(data = df,
             mapping = aes(x=Age,y=Fare,color=Sex))+
  geom_smooth(data = df %>% filter(Age >=45 & Age <=55),
              mapping = aes(x=Age,y=Fare,group = factor(Sex),color=factor(Sex)),method = "lm",se = FALSE)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 【100】ファセット機能
# 問題：dfのageとFareの散布図を表示する際、Sexグループごとに別グラフにする
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ggplot(data = df, mapping = aes(x=Age,y=Fare,color=Sex))+
  geom_point()+
  facet_grid(.~Sex)

# [Tips]facet_grid(列名①~列名②)でパネルの分割水準となるカテゴリを指定。特に指定がない場合 . を入力。
